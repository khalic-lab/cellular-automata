<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Cellular Automata</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      overflow: hidden;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(30, 30, 50, 0.9);
      padding: 20px;
      border-radius: 12px;
      color: #e0e0e0;
      min-width: 240px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 100;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    #ui::-webkit-scrollbar {
      width: 6px;
    }

    #ui::-webkit-scrollbar-track {
      background: #2a2a4a;
      border-radius: 3px;
    }

    #ui::-webkit-scrollbar-thumb {
      background: #00ff88;
      border-radius: 3px;
    }

    #ui h1 {
      font-size: 18px;
      margin-bottom: 16px;
      color: #00ff88;
      font-weight: 600;
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-row {
      display: flex;
      gap: 8px;
    }

    button {
      background: #00ff88;
      color: #1a1a2e;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.2s;
    }

    button:hover {
      background: #00cc6a;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #3a3a5a;
      color: #e0e0e0;
    }

    button.secondary:hover {
      background: #4a4a6a;
    }

    select, input[type="range"] {
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #3a3a5a;
      background: #2a2a4a;
      color: #e0e0e0;
      font-size: 14px;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #00ff88;
    }

    input[type="range"] {
      -webkit-appearance: none;
      height: 6px;
      padding: 0;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #00ff88;
      border-radius: 50%;
      cursor: pointer;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      background: #2a2a4a;
      padding: 12px;
      border-radius: 8px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 700;
      color: #00ff88;
    }

    .stat-label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .slider-value {
      text-align: right;
      font-size: 12px;
      color: #00ff88;
      margin-top: 4px;
    }

    .center-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .center-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .center-row span:first-child {
      width: 16px;
      font-size: 12px;
      color: #888;
    }

    .center-row input[type="range"] {
      flex: 1;
    }

    .center-row span:last-child {
      width: 30px;
      text-align: right;
      font-size: 12px;
      color: #00ff88;
    }

    #help {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(30, 30, 50, 0.8);
      padding: 12px 16px;
      border-radius: 8px;
      color: #888;
      font-size: 12px;
      z-index: 100;
    }

    #help strong {
      color: #e0e0e0;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <h1>3D Cellular Automata</h1>

    <div class="control-group">
      <label>Controls</label>
      <div class="control-row">
        <button id="playPause">Play</button>
        <button id="step" class="secondary">Step</button>
        <button id="reset" class="secondary">Reset</button>
      </div>
    </div>

    <div class="control-group">
      <label>Rule Preset</label>
      <select id="preset">
        <optgroup label="Growth">
          <option value="amoeba" selected>Amoeba - Organic blobs</option>
          <option value="crystal">Crystal - From tiny seed</option>
          <option value="crystal2">Crystal 2 - Fractal growth</option>
          <option value="builder">Builder - Structured</option>
          <option value="spiky">Spiky - Sharp growth</option>
          <option value="ripple">Ripple Cube - Waves</option>
          <option value="coral">Coral - Branching</option>
          <option value="pyroclastic">Pyroclastic - Explosive</option>
        </optgroup>
        <optgroup label="Patterns">
          <option value="445">445 - Symmetric</option>
          <option value="678">678 - Organic</option>
          <option value="clouds">Clouds - Diffuse</option>
          <option value="slow-decay">Slow Decay - Dissolving</option>
        </optgroup>
      </select>
    </div>

    <div class="control-group">
      <label>Grid Size</label>
      <select id="gridSize">
        <option value="10">10 x 10 x 10</option>
        <option value="15">15 x 15 x 15</option>
        <option value="20" selected>20 x 20 x 20</option>
        <option value="30">30 x 30 x 30</option>
        <option value="40">40 x 40 x 40</option>
        <option value="50">50 x 50 x 50</option>
        <option value="75">75 x 75 x 75</option>
        <option value="100">100 x 100 x 100</option>
        <option value="150">150 x 150 x 150</option>
        <option value="200">200 x 200 x 200</option>
        <option value="300">300 x 300 x 300</option>
        <option value="500">500 x 500 x 500</option>
      </select>
    </div>

    <div class="control-group">
      <label>Timeline</label>
      <input type="range" id="timeline" min="0" max="0" value="0" step="1">
      <div class="slider-value" id="timelineValue">0 / 0</div>
    </div>

    <div class="control-group">
      <label>World Center</label>
      <div class="center-controls">
        <div class="center-row">
          <span>X:</span>
          <input type="range" id="centerX" min="-50" max="50" value="0" step="1">
          <span id="centerXValue">0</span>
        </div>
        <div class="center-row">
          <span>Y:</span>
          <input type="range" id="centerY" min="-50" max="50" value="0" step="1">
          <span id="centerYValue">0</span>
        </div>
        <div class="center-row">
          <span>Z:</span>
          <input type="range" id="centerZ" min="-50" max="50" value="0" step="1">
          <span id="centerZValue">0</span>
        </div>
      </div>
    </div>

    <div class="control-group">
      <label>Speed (ms/frame)</label>
      <input type="range" id="speed" min="50" max="1000" value="200" step="50">
      <div class="slider-value" id="speedValue">200ms</div>
      <div class="control-row" style="margin-top:8px">
        <button class="secondary" id="speedFast" style="flex:1;padding:6px">Fast</button>
        <button class="secondary" id="speedNormal" style="flex:1;padding:6px">Normal</button>
        <button class="secondary" id="speedSlow" style="flex:1;padding:6px">Slow</button>
      </div>
    </div>

    <div class="control-group">
      <label>Initial Density</label>
      <input type="range" id="density" min="0.1" max="1.0" value="0.5" step="0.05">
      <div class="slider-value" id="densityValue">50%</div>
    </div>

    <div class="control-group">
      <label>Statistics</label>
      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="generation">0</div>
          <div class="stat-label">Generation</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="population">0</div>
          <div class="stat-label">Population</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="densityStat">0%</div>
          <div class="stat-label">Density</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stepTime">-</div>
          <div class="stat-label">Step Time</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="computeMode">cpu</div>
          <div class="stat-label">Compute</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="maxGen">0</div>
          <div class="stat-label">Max Gen</div>
        </div>
      </div>
    </div>

    <div class="control-group">
      <label>Population History</label>
      <canvas id="popGraph" width="200" height="40" style="width:100%; background:#2a2a4a; border-radius:4px;"></canvas>
    </div>

    <div class="control-group">
      <label>State Distribution</label>
      <div id="stateBar" style="height:12px; display:flex; border-radius:4px; overflow:hidden;"></div>
      <div id="stateLegend" style="font-size:10px; margin-top:4px; color:#888;"></div>
    </div>

    <div class="control-group">
      <label>Display Mode</label>
      <select id="displayMode">
        <option value="all">All Cells</option>
        <option value="shell">Shell Only (Surface)</option>
      </select>
    </div>

    <div class="control-group">
      <label>Slice View</label>
      <div class="center-controls">
        <div class="center-row">
          <span>Axis:</span>
          <select id="sliceAxis" style="flex:1">
            <option value="off">Off</option>
            <option value="x">X (YZ plane)</option>
            <option value="y">Y (XZ plane)</option>
            <option value="z">Z (XY plane)</option>
          </select>
        </div>
        <div class="center-row" id="slicePosRow" style="display:none">
          <span>Pos:</span>
          <input type="range" id="slicePos" min="0" max="19" value="10">
          <span id="slicePosValue">10</span>
        </div>
      </div>
      <canvas id="sliceCanvas" width="200" height="200" style="display:none; width:100%; aspect-ratio:1; background:#1a1a2e; border-radius:4px; margin-top:8px; image-rendering:pixelated;"></canvas>
    </div>

    <div class="control-group">
      <label>Camera</label>
      <div class="control-row">
        <button class="secondary" id="camFront" style="flex:1;padding:6px">Front</button>
        <button class="secondary" id="camTop" style="flex:1;padding:6px">Top</button>
        <button class="secondary" id="camCorner" style="flex:1;padding:6px">Corner</button>
      </div>
    </div>
  </div>

  <div id="help">
    <strong>Mouse:</strong> Drag to rotate, Scroll to zoom, Right-drag to pan
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ============================================================
    // INLINED CA LIBRARY
    // ============================================================

    // --- Grid Class ---
    function computeStrides(dimensions) {
      const strides = new Array(dimensions.length);
      let stride = 1;
      for (let i = dimensions.length - 1; i >= 0; i--) {
        strides[i] = stride;
        stride *= dimensions[i];
      }
      return strides;
    }

    class Grid {
      constructor(dimensions) {
        this.dimensions = [...dimensions];
        this.strides = computeStrides(dimensions);
        this.size = dimensions.reduce((prod, dim) => prod * dim, 1);
        this.data = new Uint8Array(this.size);
      }

      index(coord) {
        let idx = 0;
        for (let i = 0; i < coord.length; i++) {
          idx += coord[i] * this.strides[i];
        }
        return idx;
      }

      wrap(coord) {
        const wrapped = new Array(coord.length);
        for (let i = 0; i < coord.length; i++) {
          wrapped[i] = ((coord[i] % this.dimensions[i]) + this.dimensions[i]) % this.dimensions[i];
        }
        return wrapped;
      }

      get(coord) {
        return this.data[this.index(coord)];
      }

      set(coord, value) {
        this.data[this.index(coord)] = value;
      }

      clone() {
        const copy = new Grid(this.dimensions);
        copy.data.set(this.data);
        return copy;
      }

      countPopulation() {
        // Count cells that are alive (state > 0) for multi-state CA
        let count = 0;
        for (let i = 0; i < this.size; i++) {
          if (this.data[i] > 0) count++;
        }
        return count;
      }
    }

    // --- Random ---
    function createRandom(seed) {
      let state = seed >>> 0;
      return {
        next: () => {
          state = (state * 1664525 + 1013904223) >>> 0;
          return state / 0x100000000;
        }
      };
    }

    function initializeRandom(grid, density, { next }) {
      for (let i = 0; i < grid.size; i++) {
        grid.data[i] = next() < density ? 1 : 0;
      }
    }

    // Spherical blob initialization (inspired by williamyang98/3D-Cellular-Automata)
    // Creates one or more spheres of random cells
    // Initialize grid with a centered shape
    // radiusCells: radius for sphere, or half side-length for cube (0 = fill entire grid)
    // density: fraction of cells to fill (0-1)
    // cellMaxState: the state value for alive cells (for multi-state CA)
    // shape: 'sphere' (default) or 'cube'
    // Position-based hash random (matches williamyang98's approach)
    // Creates deterministic random values based on 3D position
    function positionHash(x, y, z, seed) {
      // Same magic numbers as williamyang98
      const a = x * 12.9898 + y * 78.233 + z * 3.2345;
      const b = Math.sin(a * seed) * 43758.5453;
      return b - Math.floor(b); // fract()
    }

    function initializeBlob(grid, density, radiusCells, cellMaxState, { next }, shape = 'sphere') {
      const dims = grid.dimensions;
      const size = dims[0];
      const size2 = size * size;

      // Clear grid first
      grid.data.fill(0);

      // Center of grid
      const center = dims.map(d => Math.floor(d / 2));

      // Use a random seed for position-based hashing
      const seed = next() * 1000 + 1;

      // If radiusCells is 0, fill the entire grid with given density
      if (radiusCells <= 0) {
        for (let x = 0; x < dims[0]; x++) {
          for (let y = 0; y < dims[1]; y++) {
            for (let z = 0; z < dims[2]; z++) {
              // Use position-based hash instead of sequential random
              if (positionHash(x, y, z, seed) < density) {
                const idx = x * size2 + y * size + z;
                grid.data[idx] = cellMaxState;
              }
            }
          }
        }
        return;
      }

      const radiusSq = radiusCells * radiusCells;

      for (let x = 0; x < dims[0]; x++) {
        for (let y = 0; y < dims[1]; y++) {
          for (let z = 0; z < dims[2]; z++) {
            const dx = x - center[0];
            const dy = y - center[1];
            const dz = z - center[2];

            let inRegion;
            if (shape === 'cube') {
              // Cube: check Chebyshev distance (max of abs distances)
              inRegion = Math.abs(dx) <= radiusCells &&
                         Math.abs(dy) <= radiusCells &&
                         Math.abs(dz) <= radiusCells;
            } else {
              // Sphere: check Euclidean distance
              inRegion = dx * dx + dy * dy + dz * dz <= radiusSq;
            }

            if (inRegion && positionHash(x, y, z, seed) < density) {
              const idx = x * size2 + y * size + z;
              grid.data[idx] = cellMaxState;
            }
          }
        }
      }
    }

    // --- Neighborhood ---
    function generateNeighborhood(dimensions, { type, range = 1 }) {
      const ndim = dimensions.length;
      const offsets = [];

      function isValidNeighbor(offset, type, range) {
        if (type === 'moore') {
          const chebyshev = Math.max(...offset.map(Math.abs));
          return chebyshev <= range;
        }
        const manhattan = offset.reduce((sum, v) => sum + Math.abs(v), 0);
        return manhattan <= range;
      }

      function generate(current, dim) {
        if (dim === ndim) {
          const isOrigin = current.every(v => v === 0);
          if (!isOrigin && isValidNeighbor(current, type, range)) {
            offsets.push([...current]);
          }
          return;
        }
        for (let offset = -range; offset <= range; offset++) {
          current[dim] = offset;
          generate(current, dim + 1);
        }
      }

      generate(new Array(ndim).fill(0), 0);
      return offsets;
    }

    function getMaxNeighbors(dimensions, type, range) {
      const ndim = dimensions.length;
      if (type === 'moore') {
        return Math.pow(2 * range + 1, ndim) - 1;
      }
      if (range === 1) {
        return 2 * ndim;
      }
      // General case for von Neumann
      let count = 0;
      const temp = new Array(ndim).fill(0);
      function countOffsets(dim) {
        if (dim === ndim) {
          const manhattan = temp.reduce((sum, v) => sum + Math.abs(v), 0);
          const isOrigin = temp.every(v => v === 0);
          if (!isOrigin && manhattan <= range) count++;
          return;
        }
        for (let offset = -range; offset <= range; offset++) {
          temp[dim] = offset;
          countOffsets(dim + 1);
        }
      }
      countOffsets(0);
      return count;
    }

    // --- Rule ---
    function createRule(birth, survival, maxNeighbors) {
      return {
        birth: new Set(birth),
        survival: new Set(survival),
        maxNeighbors
      };
    }

    function shouldCellBeAlive({ birth, survival }, currentState, neighborCount) {
      if (currentState === 1) {
        return survival.has(neighborCount);
      }
      return birth.has(neighborCount);
    }

    // --- Stepper ---
    function countNeighbors(grid, coord, neighborhood) {
      let count = 0;
      for (const offset of neighborhood) {
        const neighborCoord = coord.map((c, i) => c + offset[i]);
        const wrapped = grid.wrap(neighborCoord);
        count += grid.get(wrapped);
      }
      return count;
    }

    function stepGrid(currentGrid, nextGrid, rule, neighborhood) {
      const coord = new Array(currentGrid.dimensions.length).fill(0);

      function iterateGrid(dim) {
        if (dim === coord.length) {
          const currentState = currentGrid.get(coord);
          const neighborCount = countNeighbors(currentGrid, coord, neighborhood);
          const nextState = shouldCellBeAlive(rule, currentState, neighborCount);
          nextGrid.set(coord, nextState ? 1 : 0);
          return;
        }
        for (let i = 0; i < currentGrid.dimensions[dim]; i++) {
          coord[dim] = i;
          iterateGrid(dim + 1);
        }
      }

      iterateGrid(0);
    }

    // ============================================================
    // OPTIMIZED CA IMPLEMENTATION (Levels 1-4)
    // ============================================================

    // --- Level 1: Pre-compute neighbor index deltas ---
    function computeNeighborIndexDeltas(neighborhood, strides) {
      const deltas = new Int32Array(neighborhood.length);
      for (let n = 0; n < neighborhood.length; n++) {
        let delta = 0;
        for (let d = 0; d < strides.length; d++) {
          delta += neighborhood[n][d] * strides[d];
        }
        deltas[n] = delta;
      }
      return deltas;
    }

    // --- Level 2: Rule lookup tables (zero-allocation) ---
    function createRuleLookups(birthSet, survivalSet, maxNeighbors) {
      const birth = new Uint8Array(maxNeighbors + 1);
      const survival = new Uint8Array(maxNeighbors + 1);
      for (const b of birthSet) birth[b] = 1;
      for (const s of survivalSet) survival[s] = 1;
      return { birth, survival };
    }

    // Fast wrapping for edge cells
    function wrapIndexFast(idx, delta, size, size2, total) {
      const z = idx % size;
      const y = ((idx / size) | 0) % size;
      const x = (idx / size2) | 0;

      // Extract delta components
      const dz = delta % size;
      const dy = ((delta / size) | 0) % size;
      const dx = (delta / size2) | 0;

      // This is complex - instead use coordinate-based wrap
      const nz = ((z + delta % 3 - 1) % size + size) % size;
      const ny = ((y + Math.floor(delta / 3) % 3 - 1) % size + size) % size;
      const nx = ((x + Math.floor(delta / 9) - 1) % size + size) % size;

      return nx * size2 + ny * size + nz;
    }

    // Optimized step function (Level 1+2 combined)
    // Multi-state CA with decay (matching williamyang98 implementation):
    // - Count neighbors that are FULLY alive (state == maxState) - NOT decaying cells!
    // - Dead cell (state=0) + birth match -> maxState (born)
    // - Alive cell (state=maxState) + survival match -> maxState (stays alive)
    // - Alive cell (state=maxState) + no survival match -> maxState-1 (starts decay)
    // - Refractory cell (0 < state < maxState) -> state-1 (continues decay)
    // neighborOffsets is a flat Int8Array: [ox0, oy0, oz0, ox1, oy1, oz1, ...]
    function stepGridOptimized(currData, nextData, size, deltas, neighborOffsets, birth, survival, maxState) {
      const size2 = size * size;
      const total = size * size2;
      const numNeighbors = deltas.length;

      // Debug counters
      let births = 0, deaths = 0, survives = 0, startedDecay = 0, continuedDecay = 0;
      let neighborHist = new Array(27).fill(0); // neighbor count histogram for alive cells

      for (let idx = 0; idx < total; idx++) {
        const z = idx % size;
        const y = ((idx / size) | 0) % size;
        const x = (idx / size2) | 0;

        // Check if cell is on edge (needs wrapping)
        const isEdge = x === 0 || x === size - 1 ||
                       y === 0 || y === size - 1 ||
                       z === 0 || z === size - 1;

        // Count FULLY ALIVE neighbors (state == maxState only!)
        // Decaying/refractory cells do NOT count as neighbors
        let count = 0;
        if (isEdge) {
          // Slow path with coordinate-based wrapping using pre-computed offsets
          for (let n = 0; n < numNeighbors; n++) {
            const ox = neighborOffsets[n * 3];
            const oy = neighborOffsets[n * 3 + 1];
            const oz = neighborOffsets[n * 3 + 2];

            const nx = ((x + ox) % size + size) % size;
            const ny = ((y + oy) % size + size) % size;
            const nz = ((z + oz) % size + size) % size;

            // Only count FULLY alive cells (at maxState)
            if (currData[nx * size2 + ny * size + nz] === maxState) count++;
          }
        } else {
          // Fast path - direct index addition (no wrapping needed)
          for (let n = 0; n < numNeighbors; n++) {
            // Only count FULLY alive cells (at maxState)
            if (currData[idx + deltas[n]] === maxState) count++;
          }
        }

        // Multi-state CA logic
        const currState = currData[idx];
        if (currState === 0) {
          // Dead cell: birth if condition met
          if (birth[count]) {
            nextData[idx] = maxState;
            births++;
          } else {
            nextData[idx] = 0;
          }
        } else if (currState === maxState) {
          // Fully alive cell: check survival rule
          neighborHist[count]++;
          if (survival[count]) {
            nextData[idx] = maxState;
            survives++;
          } else {
            nextData[idx] = maxState - 1;
            startedDecay++;
          }
        } else {
          // Refractory cell (decaying): always continue decay
          if (currState === 1) {
            deaths++; // This cell will become 0 (dead)
          }
          continuedDecay++;
          nextData[idx] = currState - 1;
        }
      }

      // Log transition summary
      console.log(`  Transitions: births=${births}, survives=${survives}, startedDecay=${startedDecay}, continuedDecay=${continuedDecay}, deaths=${deaths}`);
      const histStr = neighborHist.map((c, i) => c > 0 ? `${i}:${c}` : '').filter(s => s).join(' ');
      console.log(`  Alive neighbor counts: [${histStr}]`);
    }

    // Convert neighborhood array to flat Int8Array of offsets
    function createNeighborOffsets(neighborhood) {
      const offsets = new Int8Array(neighborhood.length * 3);
      for (let n = 0; n < neighborhood.length; n++) {
        offsets[n * 3] = neighborhood[n][0];
        offsets[n * 3 + 1] = neighborhood[n][1];
        offsets[n * 3 + 2] = neighborhood[n][2];
      }
      return offsets;
    }

    // --- Level 3: Web Worker ---
    // Multi-state CA worker with decay support
    const workerCode = `
      let gridSize, size2, total;
      let currentData, nextData;
      let neighborDeltas, neighborOffsets;
      let birthLookup, survivalLookup;
      let maxState = 15; // Default, updated on init

      self.onmessage = function(e) {
        const { type, payload } = e.data;
        switch (type) {
          case 'init':
            initWorker(payload);
            break;
          case 'step':
            performStep();
            break;
          case 'reset':
            resetGrid(payload);
            break;
          case 'setRule':
            updateRule(payload);
            break;
        }
      };

      function initWorker(data) {
        gridSize = data.gridSize;
        size2 = gridSize * gridSize;
        total = size2 * gridSize;
        currentData = new Uint8Array(data.gridData);
        nextData = new Uint8Array(total);
        neighborDeltas = new Int32Array(data.deltas);
        neighborOffsets = new Int8Array(data.offsets);
        birthLookup = new Uint8Array(data.birth);
        survivalLookup = new Uint8Array(data.survival);
        maxState = data.maxState || 15;
        self.postMessage({ type: 'ready' });
      }

      function resetGrid(data) {
        currentData = new Uint8Array(data.gridData);
        nextData = new Uint8Array(total);
        if (data.maxState !== undefined) maxState = data.maxState;
        self.postMessage({ type: 'resetComplete' });
      }

      function updateRule(data) {
        birthLookup = new Uint8Array(data.birth);
        survivalLookup = new Uint8Array(data.survival);
        if (data.maxState !== undefined) maxState = data.maxState;
        self.postMessage({ type: 'ruleUpdated' });
      }

      function performStep() {
        const size = gridSize;
        const deltas = neighborDeltas;
        const offsets = neighborOffsets;
        const numNeighbors = deltas.length;
        const birth = birthLookup;
        const survival = survivalLookup;
        const currData = currentData;
        const nxtData = nextData;
        const mState = maxState;

        for (let idx = 0; idx < total; idx++) {
          const z = idx % size;
          const y = ((idx / size) | 0) % size;
          const x = (idx / size2) | 0;

          const isEdge = x === 0 || x === size - 1 ||
                         y === 0 || y === size - 1 ||
                         z === 0 || z === size - 1;

          // Count FULLY ALIVE neighbors (state == maxState only!)
          let count = 0;
          if (isEdge) {
            // Slow path with coordinate-based wrapping
            for (let n = 0; n < numNeighbors; n++) {
              const ox = offsets[n * 3];
              const oy = offsets[n * 3 + 1];
              const oz = offsets[n * 3 + 2];

              const nx = ((x + ox) % size + size) % size;
              const ny = ((y + oy) % size + size) % size;
              const nz = ((z + oz) % size + size) % size;

              if (currData[nx * size2 + ny * size + nz] === mState) count++;
            }
          } else {
            // Fast path - direct index addition
            for (let n = 0; n < numNeighbors; n++) {
              if (currData[idx + deltas[n]] === mState) count++;
            }
          }

          // Multi-state CA logic
          const currState = currData[idx];
          if (currState === 0) {
            // Dead cell: birth if condition met
            nxtData[idx] = birth[count] ? mState : 0;
          } else if (currState === mState) {
            // Fully alive: check survival
            nxtData[idx] = survival[count] ? mState : mState - 1;
          } else {
            // Refractory: always decay
            nxtData[idx] = currState - 1;
          }
        }

        // Swap buffers
        const temp = currentData;
        currentData = nextData;
        nextData = temp;

        // Send result back (transfer buffer for zero-copy)
        const buffer = currentData.buffer.slice(0);
        self.postMessage({ type: 'stepComplete', data: new Uint8Array(buffer) }, [buffer]);
      }
    `;

    function createCAWorker() {
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    // --- Level 4: WebGL Compute ---
    const webglVertexShader = `#version 300 es
      in vec2 aPosition;
      out vec2 vTexCoord;
      void main() {
        vTexCoord = aPosition * 0.5 + 0.5;
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `;

    const webglFragmentShader = `#version 300 es
      precision highp float;
      precision highp int;

      uniform sampler2D uState;
      uniform int uGridSize;
      uniform int uTexWidth;
      uniform int uBirthMask;
      uniform int uSurvivalMask;

      in vec2 vTexCoord;
      out vec4 fragColor;

      // Convert 3D grid position to 2D texture coordinate
      ivec2 gridToTex(ivec3 pos, int size, int texWidth) {
        int linearIdx = pos.x * size * size + pos.y * size + pos.z;
        return ivec2(linearIdx % texWidth, linearIdx / texWidth);
      }

      // Get cell state at wrapped 3D position
      float getCell(ivec3 pos, int size, int texWidth) {
        ivec3 wrapped = ivec3(
          (pos.x % size + size) % size,
          (pos.y % size + size) % size,
          (pos.z % size + size) % size
        );
        ivec2 texPos = gridToTex(wrapped, size, texWidth);
        return texelFetch(uState, texPos, 0).r;
      }

      void main() {
        int size = uGridSize;
        int texWidth = uTexWidth;

        // Convert texture coordinate to linear index
        ivec2 texPos = ivec2(gl_FragCoord.xy);
        int linearIdx = texPos.y * texWidth + texPos.x;

        // Check bounds
        int total = size * size * size;
        if (linearIdx >= total) {
          fragColor = vec4(0.0);
          return;
        }

        // Convert linear index to 3D position
        int z = linearIdx % size;
        int y = (linearIdx / size) % size;
        int x = linearIdx / (size * size);
        ivec3 pos = ivec3(x, y, z);

        // Count neighbors (Moore neighborhood)
        int count = 0;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) {
            for (int dz = -1; dz <= 1; dz++) {
              if (dx == 0 && dy == 0 && dz == 0) continue;
              count += int(getCell(pos + ivec3(dx, dy, dz), size, texWidth) > 0.5);
            }
          }
        }

        // Apply rules using bit masks
        float current = getCell(pos, size, texWidth);
        bool alive;
        if (current > 0.5) {
          alive = ((uSurvivalMask >> count) & 1) == 1;
        } else {
          alive = ((uBirthMask >> count) & 1) == 1;
        }

        fragColor = vec4(alive ? 1.0 : 0.0, 0.0, 0.0, 1.0);
      }
    `;

    class WebGLCACompute {
      constructor() {
        this.canvas = document.createElement('canvas');
        this.gl = this.canvas.getContext('webgl2');
        this.initialized = false;
        this.gridSize = 0;
        this.texWidth = 0;
        this.texHeight = 0;
        this.program = null;
        this.textures = [null, null];
        this.framebuffers = [null, null];
        this.currentTexIndex = 0;
      }

      init(gridSize, birthSet, survivalSet) {
        const gl = this.gl;
        if (!gl) return false;

        this.gridSize = gridSize;
        const total = gridSize * gridSize * gridSize;

        // Query GPU texture size limit
        const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        console.log(`WebGL max texture size: ${maxTexSize}`);

        // Calculate texture dimensions (power of 2 width for better performance)
        this.texWidth = Math.min(maxTexSize, Math.pow(2, Math.ceil(Math.log2(Math.sqrt(total)))));
        this.texHeight = Math.ceil(total / this.texWidth);

        // Check if texture dimensions exceed GPU limits
        if (this.texHeight > maxTexSize) {
          console.warn(`Grid ${gridSize}³ (${total} cells) exceeds WebGL texture limits (${maxTexSize}x${maxTexSize})`);
          return false;
        }

        this.canvas.width = this.texWidth;
        this.canvas.height = this.texHeight;
        gl.viewport(0, 0, this.texWidth, this.texHeight);

        // Create shader program
        this.program = this.createProgram(webglVertexShader, webglFragmentShader);
        if (!this.program) return false;

        // Create ping-pong textures and framebuffers
        for (let i = 0; i < 2; i++) {
          this.textures[i] = this.createTexture();
          this.framebuffers[i] = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.textures[i], 0);
        }

        // Create fullscreen quad
        const quadVerts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(this.program, 'aPosition');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // Set uniforms
        gl.useProgram(this.program);
        gl.uniform1i(gl.getUniformLocation(this.program, 'uGridSize'), gridSize);
        gl.uniform1i(gl.getUniformLocation(this.program, 'uTexWidth'), this.texWidth);

        this.setRule(birthSet, survivalSet);

        this.initialized = true;
        return true;
      }

      createProgram(vsSource, fsSource) {
        const gl = this.gl;
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
          console.error('Vertex shader error:', gl.getShaderInfoLog(vs));
          return null;
        }

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fsSource);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
          console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
          return null;
        }

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link error:', gl.getProgramInfoLog(program));
          return null;
        }

        return program;
      }

      createTexture() {
        const gl = this.gl;
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, this.texWidth, this.texHeight, 0, gl.RED, gl.UNSIGNED_BYTE, null);
        return tex;
      }

      setRule(birthSet, survivalSet) {
        const gl = this.gl;
        if (!this.program) return;

        let birthMask = 0;
        let survivalMask = 0;
        for (const b of birthSet) birthMask |= (1 << b);
        for (const s of survivalSet) survivalMask |= (1 << s);

        gl.useProgram(this.program);
        gl.uniform1i(gl.getUniformLocation(this.program, 'uBirthMask'), birthMask);
        gl.uniform1i(gl.getUniformLocation(this.program, 'uSurvivalMask'), survivalMask);
      }

      uploadGrid(gridData) {
        const gl = this.gl;
        const total = this.gridSize * this.gridSize * this.gridSize;

        // Pad data to texture size
        const texData = new Uint8Array(this.texWidth * this.texHeight);
        for (let i = 0; i < total; i++) {
          texData[i] = gridData[i] * 255;
        }

        gl.bindTexture(gl.TEXTURE_2D, this.textures[this.currentTexIndex]);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.texWidth, this.texHeight, gl.RED, gl.UNSIGNED_BYTE, texData);
      }

      step() {
        const gl = this.gl;
        const nextTexIndex = 1 - this.currentTexIndex;

        // Bind source texture and target framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[nextTexIndex]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textures[this.currentTexIndex]);
        gl.uniform1i(gl.getUniformLocation(this.program, 'uState'), 0);

        // Render
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // Swap
        this.currentTexIndex = nextTexIndex;
      }

      readGrid(targetData) {
        const gl = this.gl;
        const total = this.gridSize * this.gridSize * this.gridSize;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[this.currentTexIndex]);
        const texData = new Uint8Array(this.texWidth * this.texHeight * 4);
        gl.readPixels(0, 0, this.texWidth, this.texHeight, gl.RGBA, gl.UNSIGNED_BYTE, texData);

        // Extract red channel
        for (let i = 0; i < total; i++) {
          targetData[i] = texData[i * 4] > 127 ? 1 : 0;
        }
      }

      dispose() {
        const gl = this.gl;
        if (this.program) gl.deleteProgram(this.program);
        for (let i = 0; i < 2; i++) {
          if (this.textures[i]) gl.deleteTexture(this.textures[i]);
          if (this.framebuffers[i]) gl.deleteFramebuffer(this.framebuffers[i]);
        }
        this.initialized = false;
      }
    }

    // ============================================================
    // GPU CA SIMULATION + RAY MARCHING (Full GPU pipeline)
    // ============================================================

    // CA simulation shader - runs entirely on GPU using 3D textures
    const gpuCAVertexShader = `#version 300 es
      in vec2 aPosition;
      out vec2 vUV;
      void main() {
        vUV = aPosition * 0.5 + 0.5;
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `;

    // CA fragment shader - processes one Z-slice at a time
    const gpuCAFragmentShader = `#version 300 es
      precision highp float;
      precision highp sampler3D;

      uniform sampler3D uCurrentState;
      uniform int uGridSize;
      uniform int uSliceZ;
      uniform int uBirthMask;
      uniform int uSurvivalMask;

      in vec2 vUV;
      out vec4 fragColor;

      float getCell(ivec3 pos) {
        // Wrap coordinates (toroidal)
        ivec3 wrapped = (pos + uGridSize) % uGridSize;
        vec3 texCoord = (vec3(wrapped) + 0.5) / float(uGridSize);
        return texture(uCurrentState, texCoord).r;
      }

      void main() {
        int x = int(vUV.x * float(uGridSize));
        int y = int(vUV.y * float(uGridSize));
        int z = uSliceZ;
        ivec3 pos = ivec3(x, y, z);

        // Count Moore neighborhood (26 neighbors)
        int count = 0;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) {
            for (int dz = -1; dz <= 1; dz++) {
              if (dx == 0 && dy == 0 && dz == 0) continue;
              count += int(getCell(pos + ivec3(dx, dy, dz)) > 0.5);
            }
          }
        }

        // Apply rules using bit masks
        float current = getCell(pos);
        bool alive;
        if (current > 0.5) {
          alive = ((uSurvivalMask >> count) & 1) == 1;
        } else {
          alive = ((uBirthMask >> count) & 1) == 1;
        }

        fragColor = vec4(alive ? 1.0 : 0.0, 0.0, 0.0, 1.0);
      }
    `;

    // Full GPU CA + Rendering system
    // Uses raw WebGL for both CA compute and ray marching - ZERO CPU readback!
    class FullGPUPipeline {
      constructor(threeRenderer) {
        this.threeRenderer = threeRenderer;
        this.gl = threeRenderer.getContext();
        this.gridSize = 0;
        this.textures = [null, null]; // Ping-pong 3D textures for CA
        this.framebuffer = null;
        this.currentTex = 0;
        this.caProgram = null;
        this.rayMarchProgram = null;
        this.quadVAO = null;
        this.boxVAO = null;
        this.birthMask = 0;
        this.survivalMask = 0;
        this.initialized = false;
        this.population = 0;
        this.populationDirty = true;

        // Transform state
        this.worldCenter = { x: 0, y: 0, z: 0 };
      }

      init(gridSize, birthSet, survivalSet) {
        const gl = this.gl;
        this.gridSize = gridSize;

        // Check WebGL2 and 3D texture support
        if (!gl.texImage3D) {
          console.warn('WebGL2 3D textures not supported');
          return false;
        }

        const max3D = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
        if (gridSize > max3D) {
          console.warn(`Grid ${gridSize} exceeds max 3D texture size ${max3D}`);
          return false;
        }

        // Create rule masks
        this.setRule(birthSet, survivalSet);

        // Create ping-pong 3D textures
        for (let i = 0; i < 2; i++) {
          this.textures[i] = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_3D, this.textures[i]);
          gl.texImage3D(gl.TEXTURE_3D, 0, gl.R8, gridSize, gridSize, gridSize, 0, gl.RED, gl.UNSIGNED_BYTE, null);
          gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.REPEAT);
        }

        // Create framebuffer for CA slice rendering
        this.framebuffer = gl.createFramebuffer();

        // Compile CA shader program
        this.caProgram = this.createProgram(gpuCAVertexShader, gpuCAFragmentShader);
        if (!this.caProgram) return false;

        // Compile ray march shader program
        this.rayMarchProgram = this.createProgram(fullGPURayMarchVS, fullGPURayMarchFS);
        if (!this.rayMarchProgram) {
          console.error('Failed to compile ray march program');
          return false;
        }
        console.log('Ray march program compiled successfully');

        // Create fullscreen quad VAO (for CA compute)
        this.quadVAO = gl.createVertexArray();
        gl.bindVertexArray(this.quadVAO);
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        const caPos = gl.getAttribLocation(this.caProgram, 'aPosition');
        gl.enableVertexAttribArray(caPos);
        gl.vertexAttribPointer(caPos, 2, gl.FLOAT, false, 0, 0);
        gl.bindVertexArray(null);

        // Create box VAO (for ray marching)
        this.createBoxVAO();

        this.initialized = true;
        console.log(`Full GPU pipeline initialized for ${gridSize}³`);
        return true;
      }

      createProgram(vsSource, fsSource) {
        const gl = this.gl;
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
          console.error('Vertex shader error:', gl.getShaderInfoLog(vs));
          return null;
        }

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fsSource);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
          console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
          return null;
        }

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link error:', gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }

      createBoxVAO() {
        const gl = this.gl;
        const s = 0.5; // Half size, will be scaled by gridSize

        // Box vertices (8 corners)
        const vertices = new Float32Array([
          -s, -s, -s,   s, -s, -s,   s,  s, -s,  -s,  s, -s, // back (0-3)
          -s, -s,  s,   s, -s,  s,   s,  s,  s,  -s,  s,  s, // front (4-7)
        ]);

        // Box indices (12 triangles, 36 indices) - counter-clockwise winding when viewed from outside
        const indices = new Uint16Array([
          // Back face (z = -0.5)
          0, 2, 1, 0, 3, 2,
          // Front face (z = +0.5)
          4, 5, 6, 4, 6, 7,
          // Bottom face (y = -0.5)
          0, 1, 5, 0, 5, 4,
          // Top face (y = +0.5)
          3, 6, 2, 3, 7, 6,
          // Left face (x = -0.5)
          0, 4, 7, 0, 7, 3,
          // Right face (x = +0.5)
          1, 2, 6, 1, 6, 5,
        ]);

        this.boxVAO = gl.createVertexArray();
        gl.bindVertexArray(this.boxVAO);

        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(this.rayMarchProgram, 'aPosition');
        if (posLoc === -1) {
          console.error('aPosition attribute not found in ray march shader');
        }
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        gl.bindVertexArray(null);
        this.boxIndexCount = indices.length;

        console.log('Box VAO created with', this.boxIndexCount, 'indices');
      }

      uploadInitialState(gridData) {
        const gl = this.gl;
        // Convert 0/1 to 0/255 for texture
        const texData = new Uint8Array(gridData.length);
        for (let i = 0; i < gridData.length; i++) {
          texData[i] = gridData[i] * 255;
        }
        gl.bindTexture(gl.TEXTURE_3D, this.textures[this.currentTex]);
        gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, this.gridSize, this.gridSize, this.gridSize, gl.RED, gl.UNSIGNED_BYTE, texData);
        this.populationDirty = true;
      }

      setRule(birthSet, survivalSet) {
        this.birthMask = 0;
        this.survivalMask = 0;
        for (const b of birthSet) this.birthMask |= (1 << b);
        for (const s of survivalSet) this.survivalMask |= (1 << s);
      }

      step() {
        const gl = this.gl;
        const size = this.gridSize;
        const nextTex = 1 - this.currentTex;

        // Save WebGL state
        const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        const prevViewport = gl.getParameter(gl.VIEWPORT);
        const prevProgram = gl.getParameter(gl.CURRENT_PROGRAM);

        // Setup for CA computation
        gl.useProgram(this.caProgram);
        gl.bindVertexArray(this.quadVAO);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.viewport(0, 0, size, size);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);

        // Bind source texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_3D, this.textures[this.currentTex]);
        gl.uniform1i(gl.getUniformLocation(this.caProgram, 'uCurrentState'), 0);
        gl.uniform1i(gl.getUniformLocation(this.caProgram, 'uGridSize'), size);
        gl.uniform1i(gl.getUniformLocation(this.caProgram, 'uBirthMask'), this.birthMask);
        gl.uniform1i(gl.getUniformLocation(this.caProgram, 'uSurvivalMask'), this.survivalMask);

        // Render each Z-slice to the output texture
        const sliceLoc = gl.getUniformLocation(this.caProgram, 'uSliceZ');
        for (let z = 0; z < size; z++) {
          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.textures[nextTex], 0, z);
          gl.uniform1i(sliceLoc, z);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Swap textures
        this.currentTex = nextTex;
        this.populationDirty = true;

        // Restore WebGL state
        gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
        gl.viewport(prevViewport[0], prevViewport[1], prevViewport[2], prevViewport[3]);
        gl.useProgram(prevProgram);
        gl.bindVertexArray(null);
        gl.enable(gl.DEPTH_TEST);
      }

      render(camera) {
        const gl = this.gl;
        const size = this.gridSize;

        // Get camera matrices
        camera.updateMatrixWorld();
        const viewMatrix = camera.matrixWorldInverse;
        const projMatrix = camera.projectionMatrix;

        // Calculate model matrix: translate then scale (T * S)
        // Box vertices are -0.5 to 0.5, scaled by size to get -size/2 to size/2
        const modelMatrix = new THREE.Matrix4();
        modelMatrix.compose(
          new THREE.Vector3(this.worldCenter.x, this.worldCenter.y, this.worldCenter.z),
          new THREE.Quaternion(),
          new THREE.Vector3(size, size, size)
        );

        const modelViewMatrix = new THREE.Matrix4();
        modelViewMatrix.multiplyMatrices(viewMatrix, modelMatrix);

        const mvpMatrix = new THREE.Matrix4();
        mvpMatrix.multiplyMatrices(projMatrix, modelViewMatrix);

        const modelMatrixInverse = new THREE.Matrix4();
        modelMatrixInverse.copy(modelMatrix).invert();

        // Camera position in world space
        const camWorldPos = new THREE.Vector3();
        camera.getWorldPosition(camWorldPos);

        // Camera position in model/local space
        const camLocalPos = camWorldPos.clone().applyMatrix4(modelMatrixInverse);

        // Save ALL WebGL state that we'll modify
        const prevVAO = gl.getParameter(gl.VERTEX_ARRAY_BINDING);
        const prevProgram = gl.getParameter(gl.CURRENT_PROGRAM);
        const prevActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        const prevTexture3D = gl.getParameter(gl.TEXTURE_BINDING_3D);
        const prevCullFace = gl.getParameter(gl.CULL_FACE);
        const prevCullFaceMode = gl.getParameter(gl.CULL_FACE_MODE);
        const prevDepthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
        const prevDepthTest = gl.getParameter(gl.DEPTH_TEST);
        const prevDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
        const prevBlend = gl.getParameter(gl.BLEND);

        // Setup ray march rendering
        gl.useProgram(this.rayMarchProgram);
        gl.bindVertexArray(this.boxVAO);

        // Set render state for volumetric rendering
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(false); // Don't write depth - hits are inside the box
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.FRONT); // Render back faces for volume ray marching
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Bind volume texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_3D, this.textures[this.currentTex]);

        // Set uniforms
        const prog = this.rayMarchProgram;
        gl.uniformMatrix4fv(gl.getUniformLocation(prog, 'uMVPMatrix'), false, mvpMatrix.elements);
        gl.uniformMatrix4fv(gl.getUniformLocation(prog, 'uModelMatrix'), false, modelMatrix.elements);
        gl.uniformMatrix4fv(gl.getUniformLocation(prog, 'uModelMatrixInverse'), false, modelMatrixInverse.elements);
        gl.uniform3f(gl.getUniformLocation(prog, 'uCameraPos'), camWorldPos.x, camWorldPos.y, camWorldPos.z);
        gl.uniform3f(gl.getUniformLocation(prog, 'uCameraLocalPos'), camLocalPos.x, camLocalPos.y, camLocalPos.z);
        gl.uniform1i(gl.getUniformLocation(prog, 'uVolume'), 0);
        gl.uniform1f(gl.getUniformLocation(prog, 'uGridSize'), size);

        // Step scale: larger grids need bigger steps
        const stepScale = Math.max(1.0, Math.floor(size / 100));
        gl.uniform1f(gl.getUniformLocation(prog, 'uStepScale'), stepScale);

        // Draw
        gl.drawElements(gl.TRIANGLES, this.boxIndexCount, gl.UNSIGNED_SHORT, 0);

        // Restore ALL WebGL state for Three.js
        gl.bindVertexArray(prevVAO);
        gl.useProgram(prevProgram);
        gl.activeTexture(prevActiveTexture);
        gl.bindTexture(gl.TEXTURE_3D, prevTexture3D);
        gl.depthMask(prevDepthMask);
        if (prevCullFace) {
          gl.enable(gl.CULL_FACE);
        } else {
          gl.disable(gl.CULL_FACE);
        }
        gl.cullFace(prevCullFaceMode);
        if (prevDepthTest) {
          gl.enable(gl.DEPTH_TEST);
        } else {
          gl.disable(gl.DEPTH_TEST);
        }
        gl.depthFunc(prevDepthFunc);
        if (prevBlend) {
          gl.enable(gl.BLEND);
        } else {
          gl.disable(gl.BLEND);
        }
      }

      setPosition(x, y, z) {
        this.worldCenter.x = x;
        this.worldCenter.y = y;
        this.worldCenter.z = z;
      }

      // Get population - expensive, only called when needed
      getPopulation() {
        if (!this.populationDirty) return this.population;

        const gl = this.gl;
        const size = this.gridSize;
        const total = size * size * size;
        const data = new Uint8Array(total);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        for (let z = 0; z < size; z++) {
          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.textures[this.currentTex], 0, z);
          gl.readPixels(0, 0, size, size, gl.RED, gl.UNSIGNED_BYTE, data, z * size * size);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        let count = 0;
        for (let i = 0; i < total; i++) count += data[i] > 127 ? 1 : 0;
        this.population = count;
        this.populationDirty = false;
        return count;
      }

      // Download grid data to CPU (for history/timeline)
      downloadGrid(targetData) {
        const gl = this.gl;
        const size = this.gridSize;
        const total = size * size * size;
        const texData = new Uint8Array(total);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        for (let z = 0; z < size; z++) {
          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.textures[this.currentTex], 0, z);
          gl.readPixels(0, 0, size, size, gl.RED, gl.UNSIGNED_BYTE, texData, z * size * size);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Convert 0/255 back to 0/1
        for (let i = 0; i < total; i++) {
          targetData[i] = texData[i] > 127 ? 1 : 0;
        }
      }

      dispose() {
        const gl = this.gl;
        for (let i = 0; i < 2; i++) {
          if (this.textures[i]) gl.deleteTexture(this.textures[i]);
        }
        if (this.framebuffer) gl.deleteFramebuffer(this.framebuffer);
        if (this.caProgram) gl.deleteProgram(this.caProgram);
        if (this.rayMarchProgram) gl.deleteProgram(this.rayMarchProgram);
        this.initialized = false;
      }
    }

    // Raw WebGL ray march vertex shader
    const fullGPURayMarchVS = `#version 300 es
      in vec3 aPosition;

      uniform mat4 uMVPMatrix;
      uniform mat4 uModelMatrix;

      out vec3 vWorldPos;
      out vec3 vLocalPos;

      void main() {
        vLocalPos = aPosition; // -0.5 to 0.5
        vec4 worldPos = uModelMatrix * vec4(aPosition, 1.0);
        vWorldPos = worldPos.xyz;
        gl_Position = uMVPMatrix * vec4(aPosition, 1.0);
      }
    `;

    // Raw WebGL ray march fragment shader with volumetric rendering
    const fullGPURayMarchFS = `#version 300 es
      precision highp float;
      precision highp sampler3D;

      uniform sampler3D uVolume;
      uniform float uGridSize;
      uniform float uStepScale;
      uniform vec3 uCameraPos;
      uniform vec3 uCameraLocalPos;
      uniform mat4 uModelMatrixInverse;

      in vec3 vWorldPos;
      in vec3 vLocalPos;

      out vec4 fragColor;

      // Light direction (from top-right-front in local space)
      const vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
      const vec3 lightColor = vec3(1.0, 0.95, 0.9);
      const vec3 ambientColor = vec3(0.2, 0.22, 0.28);
      const vec3 cellColor = vec3(0.0, 1.0, 0.53); // Green

      vec2 intersectBox(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
        vec3 invDir = 1.0 / rayDir;
        vec3 t1 = (boxMin - rayOrigin) * invDir;
        vec3 t2 = (boxMax - rayOrigin) * invDir;
        vec3 tMin = min(t1, t2);
        vec3 tMax = max(t1, t2);
        return vec2(max(max(tMin.x, tMin.y), tMin.z), min(min(tMax.x, tMax.y), tMax.z));
      }

      float sampleVolume(vec3 localPos) {
        vec3 texCoord = localPos + 0.5;
        return texture(uVolume, texCoord).r;
      }

      // Estimate normal using central differences (gradient)
      vec3 estimateNormal(vec3 pos, float eps) {
        float dx = sampleVolume(pos + vec3(eps, 0, 0)) - sampleVolume(pos - vec3(eps, 0, 0));
        float dy = sampleVolume(pos + vec3(0, eps, 0)) - sampleVolume(pos - vec3(0, eps, 0));
        float dz = sampleVolume(pos + vec3(0, 0, eps)) - sampleVolume(pos - vec3(0, 0, eps));
        vec3 n = vec3(-dx, -dy, -dz);
        return length(n) > 0.001 ? normalize(n) : vec3(0, 1, 0);
      }

      void main() {
        vec3 rayDir = normalize(vLocalPos - uCameraLocalPos);
        vec3 boxMin = vec3(-0.5);
        vec3 boxMax = vec3(0.5);

        vec2 tHit = intersectBox(uCameraLocalPos, rayDir, boxMin, boxMax);
        if (tHit.x > tHit.y || tHit.y < 0.0) discard;

        float t = max(tHit.x, 0.0) + 0.001;
        float stepSize = uStepScale / uGridSize;
        float eps = 1.0 / uGridSize;

        // Volumetric accumulation
        vec3 accumulatedColor = vec3(0.0);
        float accumulatedAlpha = 0.0;
        float transmittance = 1.0;

        // Opacity per cell hit (lower = more transparent, see more depth)
        float cellOpacity = 0.15;

        int hitCount = 0;
        const int maxHits = 12; // Limit hits for performance

        // Ray march through volume with accumulation
        for (int i = 0; i < 512; i++) {
          if (t > tHit.y || transmittance < 0.01) break;

          vec3 pos = uCameraLocalPos + rayDir * t;
          float density = sampleVolume(pos);

          if (density > 0.5) {
            hitCount++;

            // Estimate surface normal
            vec3 normal = estimateNormal(pos, eps);

            // Diffuse lighting
            float diffuse = max(dot(normal, lightDir), 0.0) * 0.6 + 0.4;

            // Depth-based darkening
            float depth = (t - tHit.x) / (tHit.y - tHit.x);
            float depthShade = 1.0 - depth * 0.5;

            // Rim lighting
            float rim = pow(1.0 - abs(dot(normal, -rayDir)), 2.0) * 0.2;

            // Cell color with lighting
            vec3 litColor = cellColor * (ambientColor + lightColor * diffuse) * depthShade;
            litColor += rim * cellColor;

            // Specular
            vec3 halfVec = normalize(lightDir - rayDir);
            float spec = pow(max(dot(normal, halfVec), 0.0), 16.0);
            litColor += lightColor * spec * 0.2;

            // Accumulate with front-to-back compositing
            float alpha = cellOpacity * transmittance;
            accumulatedColor += litColor * alpha;
            accumulatedAlpha += alpha;
            transmittance *= (1.0 - cellOpacity);

            // Skip through this cell to find the next surface
            // March forward until we exit this cell
            for (int j = 0; j < 8; j++) {
              t += stepSize;
              if (sampleVolume(uCameraLocalPos + rayDir * t) < 0.5) break;
            }

            if (hitCount >= maxHits) break;
          }
          t += stepSize;
        }

        if (accumulatedAlpha < 0.01) discard;

        // Normalize and apply gamma
        vec3 finalColor = accumulatedColor / max(accumulatedAlpha, 0.01);
        finalColor = pow(finalColor, vec3(1.0 / 2.2));

        fragColor = vec4(finalColor, min(accumulatedAlpha * 2.0, 1.0));
      }
    `;

    // Ray marching vertex shader - transform to proper coordinate spaces
    const rayMarchVertexShader = `
      uniform mat4 uWorldMatrix;
      uniform mat4 uWorldMatrixInverse;

      varying vec3 vLocalPos;
      varying vec3 vLocalCamPos;

      void main() {
        // Pass local-space position to fragment shader
        vLocalPos = position;

        // Transform camera position to local/model space
        vLocalCamPos = (uWorldMatrixInverse * vec4(cameraPosition, 1.0)).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    // Ray marching fragment shader - first-hit rendering with configurable quality
    const rayMarchFragmentShader = `
      precision highp float;
      precision highp sampler3D;

      uniform sampler3D uVolume;
      uniform vec3 uVolumeSize;
      uniform vec3 uColor;
      uniform float uStepScale; // 1.0 = every voxel, 2.0 = every other, etc.

      varying vec3 vLocalPos;
      varying vec3 vLocalCamPos;

      // Ray-AABB intersection
      vec2 intersectBox(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
        vec3 invDir = 1.0 / rayDir;
        vec3 t1 = (boxMin - rayOrigin) * invDir;
        vec3 t2 = (boxMax - rayOrigin) * invDir;
        vec3 tMin = min(t1, t2);
        vec3 tMax = max(t1, t2);
        return vec2(max(max(tMin.x, tMin.y), tMin.z), min(min(tMax.x, tMax.y), tMax.z));
      }

      // Sample volume
      float sampleVolume(vec3 localPos) {
        vec3 texCoord = (localPos / uVolumeSize) + 0.5;
        return texture(uVolume, texCoord).r;
      }

      void main() {
        vec3 rayDir = normalize(vLocalPos - vLocalCamPos);
        vec3 boxMin = uVolumeSize * -0.5;
        vec3 boxMax = uVolumeSize * 0.5;

        vec2 tHit = intersectBox(vLocalCamPos, rayDir, boxMin, boxMax);
        if (tHit.x > tHit.y || tHit.y < 0.0) discard;

        float t = max(tHit.x, 0.0) + 0.01;
        float stepSize = uStepScale; // Configurable step size

        // Limit iterations based on step size
        for (int i = 0; i < 512; i++) {
          if (t > tHit.y) break;

          vec3 pos = vLocalCamPos + rayDir * t;
          if (sampleVolume(pos) > 0.5) {
            // Simple depth-based shading (no expensive normal calc)
            float depth = (t - tHit.x) / (tHit.y - tHit.x);
            float shade = 1.0 - depth * 0.4;
            gl_FragColor = vec4(uColor * shade, 1.0);
            return;
          }
          t += stepSize;
        }
        discard;
      }
    `;

    // 3D Texture-based volume renderer
    class VolumeCARenderer {
      constructor(threeRenderer) {
        this.renderer = threeRenderer;
        this.gl = threeRenderer.getContext();
        this.gridSize = 0;
        this.volumeTexture = null;
        this.volumeMesh = null;
        this.material = null;
        this.initialized = false;
      }

      init(gridSize, scene) {
        this.gridSize = gridSize;
        this.scene = scene;

        // Check for WebGL2 and 3D texture support
        if (!this.gl.texImage3D) {
          console.warn('WebGL2 3D textures not supported');
          return false;
        }

        // Check max 3D texture size
        const max3DSize = this.gl.getParameter(this.gl.MAX_3D_TEXTURE_SIZE);
        console.log(`Max 3D texture size: ${max3DSize}`);

        if (gridSize > max3DSize) {
          console.warn(`Grid size ${gridSize} exceeds max 3D texture size ${max3DSize}`);
          return false;
        }

        // Create 3D texture
        this.createVolumeTexture();

        // Create box geometry (volume bounds)
        const geometry = new THREE.BoxGeometry(gridSize, gridSize, gridSize);

        // Step scale: larger grids need bigger steps to stay fast
        // 100³ = 1.0, 200³ = 2.0, 500³ = 4.0
        const stepScale = Math.max(1.0, Math.floor(gridSize / 100));

        // Create ray march material
        this.material = new THREE.ShaderMaterial({
          uniforms: {
            uVolume: { value: this.volumeTexture },
            uVolumeSize: { value: new THREE.Vector3(gridSize, gridSize, gridSize) },
            uColor: { value: new THREE.Color(0x00ff88) },
            uStepScale: { value: stepScale },
            uWorldMatrix: { value: new THREE.Matrix4() },
            uWorldMatrixInverse: { value: new THREE.Matrix4() }
          },
          vertexShader: rayMarchVertexShader,
          fragmentShader: rayMarchFragmentShader,
          side: THREE.BackSide,
          transparent: false,
          depthWrite: true
        });
        console.log(`Ray march step scale: ${stepScale} for ${gridSize}³`);

        this.volumeMesh = new THREE.Mesh(geometry, this.material);
        this.volumeMesh.onBeforeRender = () => {
          // Update world matrix uniforms before each render
          this.material.uniforms.uWorldMatrix.value.copy(this.volumeMesh.matrixWorld);
          this.material.uniforms.uWorldMatrixInverse.value.copy(this.volumeMesh.matrixWorld).invert();
        };
        scene.add(this.volumeMesh);

        this.initialized = true;
        return true;
      }

      createVolumeTexture() {
        const size = this.gridSize;

        // Create Three.js Data3DTexture
        const data = new Uint8Array(size * size * size);
        this.volumeTexture = new THREE.Data3DTexture(data, size, size, size);
        this.volumeTexture.format = THREE.RedFormat;
        this.volumeTexture.type = THREE.UnsignedByteType;
        this.volumeTexture.minFilter = THREE.NearestFilter;
        this.volumeTexture.magFilter = THREE.NearestFilter;
        this.volumeTexture.wrapS = THREE.ClampToEdgeWrapping;
        this.volumeTexture.wrapT = THREE.ClampToEdgeWrapping;
        this.volumeTexture.wrapR = THREE.ClampToEdgeWrapping;
        this.volumeTexture.needsUpdate = true;
      }

      uploadGrid(gridData) {
        if (!this.volumeTexture) return;

        // Direct copy - gridData is already 0/1, texture expects 0-255
        // But since we use > 0.5 threshold, 1 works fine
        const data = this.volumeTexture.image.data;
        data.set(gridData);
        this.volumeTexture.needsUpdate = true;
      }

      setPosition(x, y, z) {
        if (this.volumeMesh) {
          this.volumeMesh.position.set(x, y, z);
        }
      }

      setColor(color) {
        if (this.material) {
          this.material.uniforms.uColor.value.set(color);
        }
      }

      dispose() {
        if (this.volumeTexture) {
          this.volumeTexture.dispose();
          this.volumeTexture = null;
        }
        if (this.volumeMesh) {
          this.scene.remove(this.volumeMesh);
          this.volumeMesh.geometry.dispose();
          this.volumeMesh = null;
        }
        if (this.material) {
          this.material.dispose();
          this.material = null;
        }
        this.initialized = false;
      }
    }

    // ============================================================
    // RULE PRESETS
    // ============================================================

    // Rule presets with initialization parameters
    // Based on Softology's 3D Cellular Automata research
    // Presets from williamyang98/3D-Cellular-Automata system_entries.js
    // Format: S[survival]/B[birth]/[states]/M (Moore) or VN (von Neumann)
    // Multi-state CA: cells decay through states when not surviving
    // - Birth: dead cell (state=0) with matching neighbors -> max state
    // - Survival: fully alive cell (state=maxState) with matching neighbors -> stays at max state
    // - Decay: alive cell without survival match -> state decrements by 1
    // - IMPORTANT: Only fully alive cells (state=maxState) count as neighbors!
    const RULE_PRESETS = {
      'amoeba': {
        // Amoeba-1: S9-26/B5-7,12-13,15/16/M
        survival: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        birth: [5,6,7,12,13,15],
        states: 16,
        // Optimized for 20³: 0.5 gives ~80% survival (was 0.3 → 21%)
        init: { radiusCells: 8, density: 0.5 }
      },
      '445': {
        // 445: S4/B4/5/M - needs exactly 4 neighbors, low density optimal
        survival: [4],
        birth: [4],
        states: 5,
        init: { radiusCells: 15, density: 0.15 }
      },
      'builder': {
        // Builder 2: S6,9/B4,6,8-9/10/M - needs 6 or 9 neighbors
        survival: [6, 9],
        birth: [4, 6, 8, 9],
        states: 10,
        init: { radiusCells: 7, density: 0.3 }
      },
      'crystal': {
        // Crystal Growth 1: S0-6/B1,3/2/VN (von Neumann neighborhood)
        survival: [0,1,2,3,4,5,6],
        birth: [1, 3],
        states: 2,
        neighborhood: 'von-neumann',
        init: { radiusCells: 1, density: 1.0 }
      },
      'crystal2': {
        // Crystal Growth 2: S1-3/B1-3/5/VN (von Neumann neighborhood)
        survival: [1, 2, 3],
        birth: [1, 2, 3],
        states: 5,
        neighborhood: 'von-neumann',
        init: { radiusCells: 1, density: 1.0 }
      },
      'clouds': {
        // Clouds 1: S13-26/B13-14,17-19/2/M - full grid
        // Optimized for 20³: 0.55 gives ~70% survival (was 0.5 → 56%)
        survival: [13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        birth: [13,14,17,18,19],
        states: 2,
        init: { radiusCells: 0, density: 0.55 }
      },
      'slow-decay': {
        // Slow Decay: S8,11,13-26/B13-26/5/M - full grid
        // Optimized for 20³: 0.5 gives ~71% survival (was 0.45 → 45%)
        survival: [8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        birth: [13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        states: 5,
        init: { radiusCells: 0, density: 0.5 }
      },
      'spiky': {
        // Spiky Growth 1: S7-26/B4,12-13,15/10/M
        // Optimized for 20³: 0.4 gives ~72% survival (was 0.32 → 46%)
        survival: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        birth: [4, 12, 13, 15],
        states: 10,
        init: { radiusCells: 7, density: 0.4 }
      },
      'ripple': {
        // Ripple Cube: S8-26/B4,12-13,15/10/M (exact williamyang98)
        // Higher density (0.5) creates denser initial cube for proper ripple wave patterns
        survival: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        birth: [4, 12, 13, 15],
        states: 10,
        init: { radiusCells: 10, density: 0.5, shape: 'cube', recommendedGridSize: 50 }
      },
      'coral': {
        // Coral: S5-8/B6-7,9,12/4/M - branching coral-like growth
        survival: [5, 6, 7, 8],
        birth: [6, 7, 9, 12],
        states: 4,
        init: { radiusCells: 6, density: 0.35 }
      },
      'pyroclastic': {
        // Pyroclastic: S4-7/B6-8/10/M - needs 4-7 neighbors, ~59% at 0.2
        survival: [4, 5, 6, 7],
        birth: [6, 7, 8],
        states: 10,
        init: { radiusCells: 5, density: 0.2 }
      },
      '678': {
        // 678 678: S6-8/B6-8/3/M - needs 6-8 neighbors, peaks at ~33%
        survival: [6, 7, 8],
        birth: [6, 7, 8],
        states: 3,
        init: { radiusCells: 5, density: 0.35 }
      }
    };

    // ============================================================
    // THREE.JS VISUALIZATION
    // ============================================================

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 200;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(50, 50, 50);
    scene.add(directionalLight);

    const directionalLight2 = new THREE.DirectionalLight(0x00ff88, 0.3);
    directionalLight2.position.set(-30, -30, 30);
    scene.add(directionalLight2);

    // Instanced meshes for cubes - separate meshes for alive vs decaying
    let aliveMesh = null;    // Fully alive cells (maxState)
    let decayMesh = null;    // Decaying cells (0 < state < maxState)
    let gridHelper = null;
    const cubeGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.85);
    const aliveGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.85); // Separate geometry for alive
    const decayGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.85); // Separate geometry for decay
    const aliveMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffdd }); // Cyan for alive
    const decayMaterial = new THREE.MeshLambertMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.8
    }); // Per-instance gradient colors for decaying

    // State
    let gridSize = 20;
    let currentGrid = null;
    let nextGrid = null;
    let rule = null;
    let neighborhood = null;
    let generation = 0;
    let isPlaying = false;
    let frameInterval = 200;
    let lastFrameTime = 0;
    let initialDensity = 0.5;
    let maxGeneration = 0;
    let maxState = 16; // Multi-state CA: cells have states 0 to maxState-1

    // Optimized CA state
    let neighborDeltas = null;
    let neighborOffsets = null;
    let ruleLookups = null;
    let caWorker = null;
    let workerReady = false;
    let pendingStep = false;
    let webglCompute = null;
    let useWebGL = false;
    let useWorker = false;

    // Full GPU pipeline (CA + ray marching, zero CPU readback during play)
    let fullGPU = null;
    let useFullGPU = false;

    // Compute mode: 'fullgpu' | 'webgl' | 'worker' | 'cpu'
    let computeMode = 'cpu';

    // Render mode: 'instanced' | 'raymarch' | 'fullgpu'
    let renderMode = 'instanced';
    let volumeRenderer = null;

    // Timeline history
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 1000;

    // World center offset
    let worldCenter = { x: 0, y: 0, z: 0 };

    // DOM elements
    const playPauseBtn = document.getElementById('playPause');
    const stepBtn = document.getElementById('step');
    const timelineSlider = document.getElementById('timeline');
    const timelineValue = document.getElementById('timelineValue');
    const centerXSlider = document.getElementById('centerX');
    const centerYSlider = document.getElementById('centerY');
    const centerZSlider = document.getElementById('centerZ');
    const centerXValue = document.getElementById('centerXValue');
    const centerYValue = document.getElementById('centerYValue');
    const centerZValue = document.getElementById('centerZValue');
    const resetBtn = document.getElementById('reset');
    const presetSelect = document.getElementById('preset');
    const gridSizeSelect = document.getElementById('gridSize');
    const speedSlider = document.getElementById('speed');
    const speedValue = document.getElementById('speedValue');
    const densitySlider = document.getElementById('density');
    const densityValue = document.getElementById('densityValue');
    const generationEl = document.getElementById('generation');
    const populationEl = document.getElementById('population');
    const densityStatEl = document.getElementById('densityStat');
    const maxGenEl = document.getElementById('maxGen');

    // New UI elements
    const displayModeSelect = document.getElementById('displayMode');
    const sliceAxisSelect = document.getElementById('sliceAxis');
    const slicePosRow = document.getElementById('slicePosRow');
    const slicePosSlider = document.getElementById('slicePos');
    const slicePosValue = document.getElementById('slicePosValue');
    const popGraphCanvas = document.getElementById('popGraph');
    const stateBar = document.getElementById('stateBar');
    const stateLegend = document.getElementById('stateLegend');

    // ============================================================
    // VISUALIZATION FEATURES
    // ============================================================

    // --- Display Mode ---
    let displayMode = 'all'; // 'all' | 'shell'

    function isSurfaceCell(idx, data, size) {
      if (data[idx] === 0) return false;
      const size2 = size * size;
      const z = idx % size;
      const y = ((idx / size) | 0) % size;
      const x = (idx / size2) | 0;

      // Check 6 direct neighbors (von Neumann)
      const neighbors = [
        [x-1, y, z], [x+1, y, z],
        [x, y-1, z], [x, y+1, z],
        [x, y, z-1], [x, y, z+1]
      ];

      for (const [nx, ny, nz] of neighbors) {
        // Wrap coordinates
        const wx = ((nx % size) + size) % size;
        const wy = ((ny % size) + size) % size;
        const wz = ((nz % size) + size) % size;
        if (data[wx * size2 + wy * size + wz] === 0) return true;
      }
      return false;
    }

    // --- Slice View ---
    let sliceAxis = 'off'; // 'off' | 'x' | 'y' | 'z'
    let slicePosition = 10;
    const sliceDisplayCanvas = document.getElementById('sliceCanvas');

    function setupSliceView() {
      // Show/hide the slice canvas based on axis selection
      sliceDisplayCanvas.style.display = sliceAxis === 'off' ? 'none' : 'block';
      if (sliceAxis !== 'off') {
        updateSliceTexture();
      }
    }

    function updateSliceTexture() {
      if (sliceAxis === 'off' || !currentGrid) return;

      const canvas = sliceDisplayCanvas;
      const ctx = canvas.getContext('2d');
      const size = gridSize;
      const size2 = size * size;
      const data = currentGrid.data;
      const pos = slicePosition;

      // Resize canvas to match grid size
      canvas.width = size;
      canvas.height = size;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, size, size);

      const imageData = ctx.createImageData(size, size);
      const pixels = imageData.data;

      // Grid data layout: idx = x * size² + y * size + z
      // Canvas layout: pixel at (col, row) where row=0 is top
      // We want Y to increase upward visually, so flip row
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          let x, y, z;

          if (sliceAxis === 'x') {
            // X slice (YZ plane): col=Z, row=Y (flip Y so 0 is bottom)
            x = pos;
            y = size - 1 - row;
            z = col;
          } else if (sliceAxis === 'y') {
            // Y slice (XZ plane): col=Z, row=X (flip X so 0 is bottom)
            x = size - 1 - row;
            y = pos;
            z = col;
          } else {
            // Z slice (XY plane): col=X, row=Y (flip Y so 0 is bottom)
            x = col;
            y = size - 1 - row;
            z = pos;
          }

          const idx = x * size2 + y * size + z;
          const state = data[idx];
          const pxIdx = (row * size + col) * 4;

          if (state === maxState) {
            // Alive - cyan
            pixels[pxIdx] = 0;
            pixels[pxIdx + 1] = 255;
            pixels[pxIdx + 2] = 221;
            pixels[pxIdx + 3] = 255;
          } else if (state > 0) {
            // Decaying - gradient from yellow to red
            const t = state / maxState;
            pixels[pxIdx] = 255;
            pixels[pxIdx + 1] = Math.floor(t * 200);
            pixels[pxIdx + 2] = 0;
            pixels[pxIdx + 3] = 255;
          } else {
            // Dead - dark background
            pixels[pxIdx] = 26;
            pixels[pxIdx + 1] = 26;
            pixels[pxIdx + 2] = 46;
            pixels[pxIdx + 3] = 255;
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // --- Population Graph ---
    const popHistory = [];
    const MAX_POP_HISTORY = 200;

    function updatePopGraph() {
      const canvas = popGraphCanvas;
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);
      if (popHistory.length < 2) return;

      const maxPop = Math.max(...popHistory);
      const minPop = Math.min(...popHistory);
      const range = maxPop - minPop || 1;

      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      popHistory.forEach((pop, i) => {
        const x = (i / (popHistory.length - 1)) * w;
        const y = h - ((pop - minPop) / range) * (h - 4) - 2;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    function recordPopulation(pop) {
      popHistory.push(pop);
      if (popHistory.length > MAX_POP_HISTORY) {
        popHistory.shift();
      }
      updatePopGraph();
    }

    function clearPopHistory() {
      popHistory.length = 0;
      updatePopGraph();
    }

    // --- State Distribution Bar ---
    function updateStateBar() {
      const data = currentGrid.data;
      const total = data.length;

      // Count states
      const counts = new Array(maxState + 1).fill(0);
      for (let i = 0; i < total; i++) {
        counts[data[i]]++;
      }

      // Generate colors
      const colors = ['#333']; // Dead = dark
      for (let i = 1; i < maxState; i++) {
        const t = i / maxState;
        const h = 30 - t * 30; // Yellow to red
        const l = 50 + t * 20;
        colors.push(`hsl(${h}, 100%, ${l}%)`);
      }
      colors.push('#00ffdd'); // Alive = cyan

      stateBar.innerHTML = counts.map((c, i) =>
        c > 0 ? `<div style="flex:${c}; background:${colors[i]}" title="State ${i}: ${(c/total*100).toFixed(1)}%"></div>` : ''
      ).join('');

      const alive = counts[maxState];
      const decaying = counts.slice(1, maxState).reduce((a,b) => a+b, 0);
      const dead = counts[0];
      stateLegend.textContent = `Alive: ${(alive/total*100).toFixed(1)}% | Decay: ${(decaying/total*100).toFixed(1)}% | Dead: ${(dead/total*100).toFixed(1)}%`;
    }

    // --- Gradient Decay Colors ---
    // Pre-computed colors for decay states: yellow (near alive) to dark red (near dead)
    function getDecayColor(state, maxState) {
      // t=1 means near alive (yellow), t=0 means near dead (dark red)
      const t = (state - 1) / Math.max(maxState - 1, 1);
      return new THREE.Color().setRGB(1.0, t * 0.8, 0); // Red to yellow
    }

    // Initialize simulation
    // useSliderValues: if true, use current slider density instead of preset default
    function initSimulation(useSliderValues = false) {
      // Create grids
      const dims = [gridSize, gridSize, gridSize];
      currentGrid = new Grid(dims);
      nextGrid = new Grid(dims);

      // Get current rule preset and its optimal initialization parameters
      const preset = RULE_PRESETS[presetSelect.value];
      const initParams = preset.init;

      // Set maxState from preset (states is count, so max value is states - 1)
      maxState = preset.states - 1;

      // Determine init parameters
      // radiusCells is always from preset (absolute cell count, or 0 for whole grid)
      const radiusCells = initParams.radiusCells;
      let density;

      if (useSliderValues) {
        // Manual override: use slider density value
        density = initialDensity;
      } else {
        // Use preset's optimal initialization
        density = initParams.density;

        // Update density slider to reflect preset value
        initialDensity = density;
        densitySlider.value = density;
        densityValue.textContent = formatDensity(density);
      }

      // Initialize with centered blob (sphere or cube depending on preset)
      // Cells are initialized to maxState (fully alive)
      const rng = createRandom(Date.now());
      const shape = initParams.shape || 'sphere';
      initializeBlob(currentGrid, density, radiusCells, maxState, rng, shape);

      // Debug: verify initialization
      let initAtMax = 0, initOther = 0;
      for (let i = 0; i < currentGrid.data.length; i++) {
        if (currentGrid.data[i] === maxState) initAtMax++;
        else if (currentGrid.data[i] > 0) initOther++;
      }
      console.log(`Init: ${initAtMax} cells at maxState=${maxState}, ${initOther} at other states, preset=${presetSelect.value}`);

      // Also check what updateMesh will see
      console.log(`Render check: maxState=${maxState}, sample cell values: ${currentGrid.data.slice(0,10).join(',')}`);

      // Count what render will show
      let willShowAlive = 0, willShowDecay = 0;
      for (let i = 0; i < currentGrid.data.length; i++) {
        if (currentGrid.data[i] === maxState) willShowAlive++;
        else if (currentGrid.data[i] > 0) willShowDecay++;
      }
      console.log(`Render will show: ${willShowAlive} cyan (alive), ${willShowDecay} orange (decay)`);

      // Generate neighborhood (Moore or von-Neumann from preset)
      const neighborhoodType = preset.neighborhood || 'moore';
      neighborhood = generateNeighborhood(dims, { type: neighborhoodType, range: 1 });
      const maxNeighbors = getMaxNeighbors(dims, neighborhoodType, 1);

      // Create rule from preset
      rule = createRule(preset.birth, preset.survival, maxNeighbors);

      // --- Level 1+2: Compute neighbor deltas, offsets, and rule lookups ---
      neighborDeltas = computeNeighborIndexDeltas(neighborhood, currentGrid.strides);
      neighborOffsets = createNeighborOffsets(neighborhood);
      ruleLookups = createRuleLookups(rule.birth, rule.survival, maxNeighbors);

      // Debug: verify rule lookups
      const surviveAt = [];
      for (let i = 0; i <= maxNeighbors; i++) {
        if (ruleLookups.survival[i]) surviveAt.push(i);
      }
      console.log(`Survival lookup: survives at [${surviveAt.join(',')}]`);

      // --- Level 3+4: Initialize compute backends with fallback ---
      initComputeBackends(preset);

      // Reset counters
      generation = 0;
      maxGeneration = 0;

      // Setup renderer - use ray marching for large grids (>= 100)
      setupRenderer();

      // Setup camera position
      const offset = gridSize * 1.2;
      camera.position.set(offset, offset * 0.8, offset);
      camera.lookAt(0, 0, 0);
      controls.update();

      // Update visualization
      updateVisualization();
      updateStats();

      // Clear and initialize history
      clearHistory();

      // Reset visualization features
      clearPopHistory();
      slicePosSlider.max = gridSize - 1;
      slicePosition = Math.floor(gridSize / 2);
      slicePosSlider.value = slicePosition;
      slicePosValue.textContent = slicePosition;
      setupSliceView();
    }

    // Initialize compute backends with automatic fallback
    function initComputeBackends(preset) {
      // Dispose previous backends
      if (caWorker) {
        caWorker.terminate();
        caWorker = null;
        workerReady = false;
      }
      if (webglCompute) {
        webglCompute.dispose();
        webglCompute = null;
      }
      if (fullGPU) {
        fullGPU.dispose();
        fullGPU = null;
      }

      pendingStep = false;
      useFullGPU = false;
      useWebGL = false;
      useWorker = false;

      // Try GPU compute for large grids (100+) - GPU simulation + instanced mesh rendering
      // This is hybrid: GPU does CA math, but we sync to CPU for instanced mesh rendering
      // NOTE: GPU shaders only support binary CA (states=2), not multi-state with decay
      const isMultiState = preset.states > 2;
      if (gridSize >= 100 && !isMultiState) {
        try {
          fullGPU = new FullGPUPipeline(renderer);
          if (fullGPU.init(gridSize, preset.birth, preset.survival)) {
            fullGPU.uploadInitialState(currentGrid.data);
            computeMode = 'fullgpu';
            // Use instanced mesh for rendering (not ray marching) - shows actual cubes
            renderMode = 'instanced';
            useFullGPU = true;
            console.log(`Using GPU compute + instanced mesh for ${gridSize}³ grid`);
            return;
          }
        } catch (e) {
          console.warn('GPU compute not available:', e);
        }
        fullGPU = null;
      }

      // Try WebGL compute for medium-large grids (50-99)
      // NOTE: WebGL shaders only support binary CA, not multi-state
      if (gridSize >= 50 && !isMultiState) {
        try {
          webglCompute = new WebGLCACompute();
          if (webglCompute.init(gridSize, preset.birth, preset.survival)) {
            webglCompute.uploadGrid(currentGrid.data);
            computeMode = 'webgl';
            useWebGL = true;
            console.log(`Using WebGL compute for ${gridSize}³ grid`);
            return;
          }
        } catch (e) {
          console.warn('WebGL compute not available:', e);
        }
        webglCompute = null;
      }

      // Try Web Worker for medium grids (30-49)
      if (gridSize >= 30 && typeof Worker !== 'undefined') {
        try {
          caWorker = createCAWorker();
          caWorker.onmessage = handleWorkerMessage;
          caWorker.onerror = (e) => {
            console.warn('Worker error, falling back to CPU:', e);
            caWorker.terminate();
            caWorker = null;
            workerReady = false;
            computeMode = 'cpu';
            useWorker = false;
          };

          // Initialize worker with current state
          caWorker.postMessage({
            type: 'init',
            payload: {
              gridSize: gridSize,
              gridData: Array.from(currentGrid.data),
              deltas: Array.from(neighborDeltas),
              offsets: Array.from(neighborOffsets),
              birth: Array.from(ruleLookups.birth),
              survival: Array.from(ruleLookups.survival),
              maxState: maxState
            }
          });

          computeMode = 'worker';
          useWorker = true;
          console.log(`Using Web Worker for ${gridSize}³ grid`);
          return;
        } catch (e) {
          console.warn('Web Worker not available:', e);
          caWorker = null;
        }
      }

      // Fallback to optimized CPU (Level 1+2)
      computeMode = 'cpu';
      console.log(`Using optimized CPU for ${gridSize}³ grid`);
    }

    // Handle messages from Web Worker
    let workerStepStart = 0;

    function handleWorkerMessage(e) {
      const { type, data } = e.data;
      switch (type) {
        case 'ready':
          workerReady = true;
          break;
        case 'stepComplete':
          const t0 = performance.now();
          currentGrid.data.set(data);
          pendingStep = false;
          generation++;
          if (generation > maxGeneration) maxGeneration = generation;
          saveToHistory();
          updateVisualization();
          lastStepTime = performance.now() - workerStepStart;
          updateStats();
          break;
        case 'resetComplete':
        case 'ruleUpdated':
          pendingStep = false;
          break;
      }
    }

    // Maximum instances we can render (1M instances = 64MB buffer, reasonable limit)
    const MAX_RENDER_INSTANCES = 1000000;

    // Threshold for switching to ray marching
    // DISABLED: Ray marching is slower than instanced mesh without GPU-based CA simulation
    // because we're still uploading 125MB per frame for 500³
    const RAYMARCH_THRESHOLD = 9999; // Effectively disabled

    function setupRenderer() {
      // Dispose previous renderers (but not fullGPU - it's handled in initComputeBackends)
      disposeRenderer();

      // Always use instanced mesh for rendering - shows actual cubes
      // GPU compute modes (fullGPU, webgl) just handle the CA simulation
      renderMode = 'instanced';
      setupInstancedMesh();

      // Create grid helper (wireframe box)
      setupGridHelper();
    }

    function disposeRenderer() {
      if (aliveMesh) {
        scene.remove(aliveMesh);
        aliveMesh.dispose();
        aliveMesh = null;
      }
      if (decayMesh) {
        scene.remove(decayMesh);
        decayMesh.dispose();
        decayMesh = null;
      }
      if (volumeRenderer) {
        volumeRenderer.dispose();
        volumeRenderer = null;
      }
      if (gridHelper) {
        scene.remove(gridHelper);
        gridHelper.geometry.dispose();
        gridHelper.material.dispose();
        gridHelper = null;
      }
    }

    function setupInstancedMesh() {
      // Create instanced meshes - cap at MAX_RENDER_INSTANCES to avoid memory issues
      const totalCells = gridSize * gridSize * gridSize;
      const maxInstances = Math.min(totalCells, MAX_RENDER_INSTANCES);

      // Mesh for fully alive cells (uses separate geometry to avoid attribute bleeding)
      aliveMesh = new THREE.InstancedMesh(aliveGeometry, aliveMaterial, maxInstances);
      aliveMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(aliveMesh);

      // Mesh for decaying cells with per-instance gradient colors
      decayMesh = new THREE.InstancedMesh(decayGeometry, decayMaterial, maxInstances);
      decayMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      // Initialize instance colors - fill with orange as default
      const defaultColor = new THREE.Color(1.0, 0.5, 0);
      for (let i = 0; i < maxInstances; i++) {
        decayMesh.setColorAt(i, defaultColor);
      }
      decayMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
      scene.add(decayMesh);
    }

    function setupGridHelper() {
      const boxGeom = new THREE.BoxGeometry(gridSize, gridSize, gridSize);
      const edgesGeom = new THREE.EdgesGeometry(boxGeom);
      gridHelper = new THREE.LineSegments(
        edgesGeom,
        new THREE.LineBasicMaterial({ color: 0x3a3a5a, linewidth: 1 })
      );
      scene.add(gridHelper);
      boxGeom.dispose();
    }

    function updateVisualization() {
      // Always use instanced mesh rendering - shows actual 3D cubes
      updateMesh();
    }

    function updateVolume() {
      // Upload grid data to 3D texture
      volumeRenderer.uploadGrid(currentGrid.data);
      volumeRenderer.setPosition(worldCenter.x, worldCenter.y, worldCenter.z);

      // Update grid helper position
      if (gridHelper) {
        gridHelper.position.set(worldCenter.x, worldCenter.y, worldCenter.z);
      }
    }

    function updateMesh() {
      if (!aliveMesh || !decayMesh) return;

      const matrix = new THREE.Matrix4();
      const halfSize = gridSize / 2;
      const size = gridSize;
      const size2 = size * size;
      const data = currentGrid.data;
      const total = data.length;
      const ox = worldCenter.x - halfSize + 0.5;
      const oy = worldCenter.y - halfSize + 0.5;
      const oz = worldCenter.z - halfSize + 0.5;
      const maxInstances = Math.min(total, MAX_RENDER_INSTANCES);
      let aliveIndex = 0;
      let decayIndex = 0;

      // Direct array iteration - separate alive and decaying cells
      for (let idx = 0; idx < total; idx++) {
        const state = data[idx];
        if (state) {
          // Shell mode: skip interior cells
          if (displayMode === 'shell' && !isSurfaceCell(idx, data, size)) {
            continue;
          }

          const z = idx % size;
          const y = ((idx / size) | 0) % size;
          const x = (idx / size2) | 0;
          matrix.setPosition(x + ox, y + oy, z + oz);

          if (state === maxState) {
            // Fully alive - cyan mesh
            if (aliveIndex < maxInstances) {
              aliveMesh.setMatrixAt(aliveIndex++, matrix);
            }
          } else {
            // Decaying - gradient color based on state
            if (decayIndex < maxInstances) {
              decayMesh.setMatrixAt(decayIndex, matrix);
              decayMesh.setColorAt(decayIndex, getDecayColor(state, maxState));
              decayIndex++;
            }
          }
        }
      }

      aliveMesh.count = aliveIndex;
      aliveMesh.instanceMatrix.needsUpdate = true;

      decayMesh.count = decayIndex;
      decayMesh.instanceMatrix.needsUpdate = true;
      decayMesh.instanceColor.needsUpdate = true;

      // Update grid helper position
      if (gridHelper) {
        gridHelper.position.set(worldCenter.x, worldCenter.y, worldCenter.z);
      }

      // Update slice texture if active
      updateSliceTexture();
    }

    let lastStepTime = 0;
    let lastPopulation = 0;

    function stepSimulation() {
      const t0 = performance.now();
      const popBefore = currentGrid.countPopulation();
      // Count state distribution
      const stateCounts = new Array(maxState + 1).fill(0);
      for (let i = 0; i < currentGrid.data.length; i++) {
        stateCounts[currentGrid.data[i]]++;
      }
      const stateStr = stateCounts.map((c, i) => `s${i}:${c}`).filter(s => !s.endsWith(':0')).join(' ');
      console.log(`=== Step ${generation} -> ${generation+1} (${computeMode}, maxState=${maxState}) ===`);
      console.log(`Population before: ${popBefore}, states: [${stateStr}]`);

      // Use appropriate compute backend
      if (computeMode === 'fullgpu' && fullGPU && fullGPU.initialized) {
        // GPU compute - CA runs on GPU, then sync to CPU for instanced mesh rendering
        fullGPU.step();
        // Download result to CPU grid for instanced mesh rendering
        fullGPU.downloadGrid(currentGrid.data);
        generation++;
        if (generation > maxGeneration) maxGeneration = generation;
        // Save to history periodically for large grids
        if (gridSize <= 100 || generation % 10 === 0) {
          saveToHistory();
        }
        // Update instanced mesh with new data
        updateVisualization();
      } else if (computeMode === 'webgl' && webglCompute && webglCompute.initialized) {
        // WebGL compute (Level 4)
        webglCompute.step();
        webglCompute.readGrid(currentGrid.data);
        generation++;
        if (generation > maxGeneration) maxGeneration = generation;
        saveToHistory();
        updateVisualization();
      } else if (computeMode === 'worker' && caWorker && workerReady) {
        // Web Worker (Level 3) - async
        if (pendingStep) return; // Skip if worker is busy
        pendingStep = true;
        workerStepStart = performance.now();
        caWorker.postMessage({ type: 'step' });
        // Result handled in handleWorkerMessage
        return; // Stats updated in handler
      } else {
        // Optimized CPU (Level 1+2)
        stepGridOptimized(
          currentGrid.data,
          nextGrid.data,
          gridSize,
          neighborDeltas,
          neighborOffsets,
          ruleLookups.birth,
          ruleLookups.survival,
          maxState
        );

        // Swap grids
        [currentGrid, nextGrid] = [nextGrid, currentGrid];

        generation++;
        if (generation > maxGeneration) maxGeneration = generation;
        saveToHistory();
        updateVisualization();
      }

      lastStepTime = performance.now() - t0;
      const popAfter = currentGrid.countPopulation();
      console.log(`Population after: ${popAfter} (delta: ${popAfter - popBefore})`);
      if (Math.abs(popAfter - popBefore) > popBefore * 0.3) {
        console.warn(`!!! LARGE POPULATION CHANGE: ${((popAfter - popBefore) / popBefore * 100).toFixed(1)}%`);
      }
      updateStats();
    }

    // Save to history when using fullGPU (downloads from GPU)
    function saveToHistoryFromGPU() {
      if (!fullGPU || !fullGPU.initialized) return;

      // Limit history for large grids
      const maxHistory = gridSize >= 300 ? 5 : gridSize >= 200 ? 10 : gridSize >= 100 ? 20 : MAX_HISTORY;

      // Truncate forward history if not at end
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }

      // Download grid data from GPU
      const data = new Uint8Array(currentGrid.size);
      fullGPU.downloadGrid(data);
      currentGrid.data.set(data); // Keep CPU grid in sync for timeline

      // Save state
      history.push({
        data: new Uint8Array(data),
        generation: generation
      });

      // Limit history size
      if (history.length > maxHistory) {
        history.shift();
      } else {
        historyIndex++;
      }

      updateTimelineUI();
    }

    function updateStats() {
      // Count population from grid data (more accurate than mesh counts for shell mode)
      lastPopulation = currentGrid.countPopulation();
      const density = (lastPopulation / currentGrid.size * 100).toFixed(1);

      generationEl.textContent = generation;
      populationEl.textContent = lastPopulation;
      densityStatEl.textContent = density + '%';
      maxGenEl.textContent = maxGeneration;
      document.getElementById('stepTime').textContent = lastStepTime.toFixed(0) + 'ms';
      document.getElementById('computeMode').textContent = computeMode;

      // Update population graph
      recordPopulation(lastPopulation);

      // Update state distribution bar
      updateStateBar();
    }

    // History management
    function saveToHistory() {
      // Limit history based on grid size to avoid memory issues
      // 500³ = 125MB per snapshot, 200³ = 8MB, 100³ = 1MB
      const maxHistory = gridSize >= 300 ? 5 : gridSize >= 200 ? 10 : gridSize >= 100 ? 50 : gridSize >= 50 ? 200 : MAX_HISTORY;

      // If we're not at the end of history, truncate forward history
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }

      // Save current state
      history.push({
        data: new Uint8Array(currentGrid.data),
        generation: generation
      });

      // Limit history size
      if (history.length > maxHistory) {
        history.shift();
      } else {
        historyIndex++;
      }

      updateTimelineUI();
    }

    function restoreFromHistory(index) {
      if (index < 0 || index >= history.length) return;

      historyIndex = index;
      const state = history[historyIndex];

      currentGrid.data.set(state.data);
      generation = state.generation;

      // Sync with compute backends
      if (computeMode === 'fullgpu' && fullGPU && fullGPU.initialized) {
        fullGPU.uploadInitialState(currentGrid.data);
      } else if (computeMode === 'webgl' && webglCompute && webglCompute.initialized) {
        webglCompute.uploadGrid(currentGrid.data);
      } else if (computeMode === 'worker' && caWorker && workerReady) {
        caWorker.postMessage({
          type: 'reset',
          payload: { gridData: Array.from(currentGrid.data), maxState: maxState }
        });
      }

      updateVisualization();
      updateStats();
      updateTimelineUI();
    }

    function updateTimelineUI() {
      timelineSlider.max = Math.max(0, history.length - 1);
      timelineSlider.value = historyIndex;
      timelineValue.textContent = `${historyIndex + 1} / ${history.length}`;
    }

    function clearHistory() {
      history = [];
      historyIndex = -1;
      // Save initial state
      saveToHistory();
    }

    // Event handlers
    playPauseBtn.addEventListener('click', () => {
      if (isPlaying) {
        // If playing, reset the simulation (keep current slider values)
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        initSimulation(true);
      } else {
        // If paused, start playing
        isPlaying = true;
        playPauseBtn.textContent = 'Reset';
      }
    });

    stepBtn.addEventListener('click', () => {
      if (!isPlaying) {
        stepSimulation();
      }
    });

    resetBtn.addEventListener('click', () => {
      isPlaying = false;
      playPauseBtn.textContent = 'Play';
      initSimulation(true); // Keep current slider values
    });

    // Timeline control
    timelineSlider.addEventListener('input', () => {
      if (isPlaying) {
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
      }
      restoreFromHistory(parseInt(timelineSlider.value));
    });

    // World center controls
    function updateWorldCenter() {
      worldCenter.x = parseInt(centerXSlider.value);
      worldCenter.y = parseInt(centerYSlider.value);
      worldCenter.z = parseInt(centerZSlider.value);
      centerXValue.textContent = worldCenter.x;
      centerYValue.textContent = worldCenter.y;
      centerZValue.textContent = worldCenter.z;
      updateVisualization();
    }

    centerXSlider.addEventListener('input', updateWorldCenter);
    centerYSlider.addEventListener('input', updateWorldCenter);
    centerZSlider.addEventListener('input', updateWorldCenter);

    presetSelect.addEventListener('change', () => {
      const preset = RULE_PRESETS[presetSelect.value];
      const initParams = preset.init;
      const newMaxState = preset.states - 1;

      // Check if preset has a recommended grid size OR different states count
      // (different states requires reinitialization because cell values won't match)
      if ((initParams.recommendedGridSize && gridSize < initParams.recommendedGridSize) ||
          newMaxState !== maxState) {
        // Update grid size if needed
        if (initParams.recommendedGridSize && gridSize < initParams.recommendedGridSize) {
          gridSize = initParams.recommendedGridSize;
          gridSizeSelect.value = gridSize.toString();
        }
        // Full reinitialization
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        initSimulation(false); // Use preset values
        return;
      }

      const maxNeighbors = getMaxNeighbors([gridSize, gridSize, gridSize], 'moore', 1);
      rule = createRule(preset.birth, preset.survival, maxNeighbors);

      // Update maxState from preset
      maxState = preset.states - 1;

      // Update optimized rule lookups
      ruleLookups = createRuleLookups(rule.birth, rule.survival, maxNeighbors);

      // Update compute backends
      if (computeMode === 'fullgpu' && fullGPU && fullGPU.initialized) {
        fullGPU.setRule(preset.birth, preset.survival);
      } else if (computeMode === 'webgl' && webglCompute) {
        webglCompute.setRule(preset.birth, preset.survival);
      } else if (computeMode === 'worker' && caWorker && workerReady) {
        caWorker.postMessage({
          type: 'setRule',
          payload: {
            birth: Array.from(ruleLookups.birth),
            survival: Array.from(ruleLookups.survival),
            maxState: maxState
          }
        });
      }

      // Update density slider to show preset's optimal value (but don't reinitialize)
      initialDensity = initParams.density;
      densitySlider.value = initParams.density;
      densityValue.textContent = formatDensity(initParams.density);
    });

    gridSizeSelect.addEventListener('change', () => {
      gridSize = parseInt(gridSizeSelect.value);
      isPlaying = false;
      playPauseBtn.textContent = 'Play';
      initSimulation(true); // Keep current slider values
    });

    speedSlider.addEventListener('input', () => {
      frameInterval = parseInt(speedSlider.value);
      speedValue.textContent = frameInterval + 'ms';
    });

    function formatDensity(value) {
      const pct = value * 100;
      return pct < 1 ? pct.toFixed(1) + '%' : Math.round(pct) + '%';
    }

    densitySlider.addEventListener('change', () => {
      initialDensity = parseFloat(densitySlider.value);
      densityValue.textContent = formatDensity(initialDensity);
      isPlaying = false;
      playPauseBtn.textContent = 'Play';
      initSimulation(true); // Use slider values as override
    });

    densitySlider.addEventListener('input', () => {
      densityValue.textContent = formatDensity(parseFloat(densitySlider.value));
    });

    // Window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ============================================================
    // NEW UI EVENT HANDLERS
    // ============================================================

    // --- Display Mode ---
    displayModeSelect.addEventListener('change', () => {
      displayMode = displayModeSelect.value;
      updateVisualization();
    });

    // --- Slice View ---
    sliceAxisSelect.addEventListener('change', () => {
      sliceAxis = sliceAxisSelect.value;
      slicePosRow.style.display = sliceAxis === 'off' ? 'none' : 'flex';
      setupSliceView();
    });

    slicePosSlider.addEventListener('input', () => {
      slicePosition = parseInt(slicePosSlider.value);
      slicePosValue.textContent = slicePosition;
      updateSliceTexture();
    });

    // --- Camera Presets ---
    document.getElementById('camFront').addEventListener('click', () => {
      const offset = gridSize * 1.5;
      camera.position.set(0, 0, offset);
      camera.lookAt(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.target.set(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.update();
    });

    document.getElementById('camTop').addEventListener('click', () => {
      const offset = gridSize * 1.5;
      camera.position.set(0, offset, 0);
      camera.lookAt(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.target.set(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.update();
    });

    document.getElementById('camCorner').addEventListener('click', () => {
      const offset = gridSize * 1.2;
      camera.position.set(offset, offset * 0.8, offset);
      camera.lookAt(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.target.set(worldCenter.x, worldCenter.y, worldCenter.z);
      controls.update();
    });

    // --- Speed Presets ---
    function setSpeed(ms) {
      frameInterval = ms;
      speedSlider.value = ms;
      speedValue.textContent = ms + 'ms';
    }

    document.getElementById('speedFast').addEventListener('click', () => setSpeed(50));
    document.getElementById('speedNormal').addEventListener('click', () => setSpeed(200));
    document.getElementById('speedSlow').addEventListener('click', () => setSpeed(500));

    // Animation loop
    function animate(currentTime) {
      requestAnimationFrame(animate);

      // Update simulation
      if (isPlaying && currentTime - lastFrameTime >= frameInterval) {
        stepSimulation();
        lastFrameTime = currentTime;
      }

      // Update controls
      controls.update();

      // Render Three.js scene (instanced mesh cubes + grid helper)
      renderer.render(scene, camera);
    }

    // Start
    initSimulation();
    animate(0);

    // ============================================================
    // TEST INTERFACE
    // ============================================================
    // Expose test interface for E2E testing with Playwright
    window.__CA_TEST__ = {
      getState: () => ({
        gridSize,
        generation,
        isPlaying,
        frameInterval,
        initialDensity,
        population: currentGrid?.countPopulation() ?? 0,
        computeMode,
        workerReady,
        webglInitialized: webglCompute?.initialized ?? false
      }),

      getRendererInfo: () => ({
        meshCount: (aliveMesh?.count ?? 0) + (decayMesh?.count ?? 0),
        isContextLost: renderer?.getContext()?.isContextLost() ?? true
      }),

      actions: {
        step: () => stepBtn.click(),
        reset: () => resetBtn.click(),
        play: () => { if (!isPlaying) playPauseBtn.click(); },
        pause: () => { if (isPlaying) playPauseBtn.click(); }
      }
    };
  </script>
</body>
</html>
